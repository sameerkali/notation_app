{"ast":null,"code":"/** @license React v0.13.6\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var enableSchedulerDebugging = false;\n    /* eslint-disable no-var */\n    // TODO: Use symbols?\n\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY = maxSigned31BitInt; // Callbacks are stored as a circular, doubly linked list.\n\n    var firstCallbackNode = null;\n    var currentDidTimeout = false; // Pausing the scheduler is useful for debugging.\n\n    var isSchedulerPaused = false;\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1; // This is set when a callback is being executed, to prevent re-entrancy.\n\n    var isExecutingCallback = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      } // Schedule the host callback using the earliest expiration in the list.\n\n\n      var expirationTime = firstCallbackNode.expirationTime;\n\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n\n      _requestHostCallback(flushWork, expirationTime);\n    }\n\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n\n      var next = firstCallbackNode.next;\n\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n\n      flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback.\n\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n\n      try {\n        continuationCallback = callback();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      } // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n\n\n      if (typeof continuationCallback === 'function') {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        }; // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n\n            node = node.next;\n          } while (node !== firstCallbackNode);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n\n    function flushImmediateWork() {\n      if ( // Confirm we've exited the outer most event handler\n      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n        isExecutingCallback = true;\n\n        try {\n          do {\n            flushFirstCallback();\n          } while ( // Keep flushing until there are no more immediate callbacks\n          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n        } finally {\n          isExecutingCallback = false;\n\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n\n    function flushWork(didTimeout) {\n      // Exit right away if we're currently paused\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      }\n\n      isExecutingCallback = true;\n      var previousDidTimeout = currentDidTimeout;\n      currentDidTimeout = didTimeout;\n\n      try {\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n            // TODO Wrap in feature flag\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\n\n              continue;\n            }\n\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              if (enableSchedulerDebugging && isSchedulerPaused) {\n                break;\n              }\n\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && !shouldYieldToHost());\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n        currentDidTimeout = previousDidTimeout;\n\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        } // Before exiting, flush all the immediate work that was scheduled.\n\n\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled.\n\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel = void 0;\n\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled.\n\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n      var expirationTime;\n\n      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n\n          case LowPriority:\n            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n            break;\n\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n\n      var newNode = {\n        callback: callback,\n        priorityLevel: currentPriorityLevel,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      }; // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled();\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n\n        do {\n          if (node.expirationTime > expirationTime) {\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n\n          node = node.next;\n        } while (node !== firstCallbackNode);\n\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n\n      return newNode;\n    }\n\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n\n      if (firstCallbackNode !== null) {\n        ensureHostCallbackIsScheduled();\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return firstCallbackNode;\n    }\n\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      callbackNode.next = callbackNode.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    function unstable_shouldYield() {\n      return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n    } // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n\n\n    var localDate = Date; // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined; // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n\n    var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n\n    var _requestHostCallback;\n\n    var cancelHostCallback;\n    var shouldYieldToHost;\n    var globalValue = null;\n\n    if (typeof window !== 'undefined') {\n      globalValue = window;\n    } else if (typeof global !== 'undefined') {\n      globalValue = global;\n    }\n\n    if (globalValue && globalValue._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var globalImpl = globalValue._schedMock;\n      _requestHostCallback = globalImpl[0];\n      cancelHostCallback = globalImpl[1];\n      shouldYieldToHost = globalImpl[2];\n      exports.unstable_now = globalImpl[3];\n    } else if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' || // Check if MessageChannel is supported, too.\n    typeof MessageChannel !== 'function') {\n      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n      // fallback to a naive implementation.\n      var _callback = null;\n\n      var _flushCallback = function _flushCallback(didTimeout) {\n        if (_callback !== null) {\n          try {\n            _callback(didTimeout);\n          } finally {\n            _callback = null;\n          }\n        }\n      };\n\n      _requestHostCallback = function requestHostCallback(cb, ms) {\n        if (_callback !== null) {\n          // Protect against re-entrancy.\n          setTimeout(_requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0, false);\n        }\n      };\n\n      cancelHostCallback = function cancelHostCallback() {\n        _callback = null;\n      };\n\n      shouldYieldToHost = function shouldYieldToHost() {\n        return false;\n      };\n    } else {\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n\n      var scheduledHostCallback = null;\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n\n      shouldYieldToHost = function shouldYieldToHost() {\n        return frameDeadline <= exports.unstable_now();\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var channel = new MessageChannel();\n      var port = channel.port2;\n\n      channel.port1.onmessage = function (event) {\n        isMessageEventScheduled = false;\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            } // Exit without invoking the callback.\n\n\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      };\n\n      var animationTick = function animationTick(rafTime) {\n        if (scheduledHostCallback !== null) {\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          port.postMessage(undefined);\n        }\n      };\n\n      _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        timeoutTime = absoluteTimeout;\n\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          port.postMessage(undefined);\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n\n      cancelHostCallback = function cancelHostCallback() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","enableSchedulerDebugging","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentDidTimeout","isSchedulerPaused","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","ensureHostCallbackIsScheduled","expirationTime","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","didTimeout","previousDidTimeout","currentTime","unstable_now","shouldYieldToHost","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","unstable_shouldYield","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","globalValue","window","global","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority"],"sources":["C:/Users/Administrator/Documents/GitHub/notation_app/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v0.13.6\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar enableSchedulerDebugging = false;\r\n\r\n/* eslint-disable no-var */\r\n\r\n// TODO: Use symbols?\r\nvar ImmediatePriority = 1;\r\nvar UserBlockingPriority = 2;\r\nvar NormalPriority = 3;\r\nvar LowPriority = 4;\r\nvar IdlePriority = 5;\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nvar maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nvar USER_BLOCKING_PRIORITY = 250;\r\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\r\nvar LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nvar IDLE_PRIORITY = maxSigned31BitInt;\r\n\r\n// Callbacks are stored as a circular, doubly linked list.\r\nvar firstCallbackNode = null;\r\n\r\nvar currentDidTimeout = false;\r\n// Pausing the scheduler is useful for debugging.\r\nvar isSchedulerPaused = false;\r\n\r\nvar currentPriorityLevel = NormalPriority;\r\nvar currentEventStartTime = -1;\r\nvar currentExpirationTime = -1;\r\n\r\n// This is set when a callback is being executed, to prevent re-entrancy.\r\nvar isExecutingCallback = false;\r\n\r\nvar isHostCallbackScheduled = false;\r\n\r\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\r\n\r\nfunction ensureHostCallbackIsScheduled() {\r\n  if (isExecutingCallback) {\r\n    // Don't schedule work yet; wait until the next time we yield.\r\n    return;\r\n  }\r\n  // Schedule the host callback using the earliest expiration in the list.\r\n  var expirationTime = firstCallbackNode.expirationTime;\r\n  if (!isHostCallbackScheduled) {\r\n    isHostCallbackScheduled = true;\r\n  } else {\r\n    // Cancel the existing host callback.\r\n    cancelHostCallback();\r\n  }\r\n  requestHostCallback(flushWork, expirationTime);\r\n}\r\n\r\nfunction flushFirstCallback() {\r\n  var flushedNode = firstCallbackNode;\r\n\r\n  // Remove the node from the list before calling the callback. That way the\r\n  // list is in a consistent state even if the callback throws.\r\n  var next = firstCallbackNode.next;\r\n  if (firstCallbackNode === next) {\r\n    // This is the last callback in the list.\r\n    firstCallbackNode = null;\r\n    next = null;\r\n  } else {\r\n    var lastCallbackNode = firstCallbackNode.previous;\r\n    firstCallbackNode = lastCallbackNode.next = next;\r\n    next.previous = lastCallbackNode;\r\n  }\r\n\r\n  flushedNode.next = flushedNode.previous = null;\r\n\r\n  // Now it's safe to call the callback.\r\n  var callback = flushedNode.callback;\r\n  var expirationTime = flushedNode.expirationTime;\r\n  var priorityLevel = flushedNode.priorityLevel;\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousExpirationTime = currentExpirationTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentExpirationTime = expirationTime;\r\n  var continuationCallback;\r\n  try {\r\n    continuationCallback = callback();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentExpirationTime = previousExpirationTime;\r\n  }\r\n\r\n  // A callback may return a continuation. The continuation should be scheduled\r\n  // with the same priority and expiration as the just-finished callback.\r\n  if (typeof continuationCallback === 'function') {\r\n    var continuationNode = {\r\n      callback: continuationCallback,\r\n      priorityLevel: priorityLevel,\r\n      expirationTime: expirationTime,\r\n      next: null,\r\n      previous: null\r\n    };\r\n\r\n    // Insert the new callback into the list, sorted by its expiration. This is\r\n    // almost the same as the code in `scheduleCallback`, except the callback\r\n    // is inserted into the list *before* callbacks of equal expiration instead\r\n    // of after.\r\n    if (firstCallbackNode === null) {\r\n      // This is the first callback in the list.\r\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\r\n    } else {\r\n      var nextAfterContinuation = null;\r\n      var node = firstCallbackNode;\r\n      do {\r\n        if (node.expirationTime >= expirationTime) {\r\n          // This callback expires at or after the continuation. We will insert\r\n          // the continuation *before* this callback.\r\n          nextAfterContinuation = node;\r\n          break;\r\n        }\r\n        node = node.next;\r\n      } while (node !== firstCallbackNode);\r\n\r\n      if (nextAfterContinuation === null) {\r\n        // No equal or lower priority callback was found, which means the new\r\n        // callback is the lowest priority callback in the list.\r\n        nextAfterContinuation = firstCallbackNode;\r\n      } else if (nextAfterContinuation === firstCallbackNode) {\r\n        // The new callback is the highest priority callback in the list.\r\n        firstCallbackNode = continuationNode;\r\n        ensureHostCallbackIsScheduled();\r\n      }\r\n\r\n      var previous = nextAfterContinuation.previous;\r\n      previous.next = nextAfterContinuation.previous = continuationNode;\r\n      continuationNode.next = nextAfterContinuation;\r\n      continuationNode.previous = previous;\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushImmediateWork() {\r\n  if (\r\n  // Confirm we've exited the outer most event handler\r\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\r\n    isExecutingCallback = true;\r\n    try {\r\n      do {\r\n        flushFirstCallback();\r\n      } while (\r\n      // Keep flushing until there are no more immediate callbacks\r\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\r\n    } finally {\r\n      isExecutingCallback = false;\r\n      if (firstCallbackNode !== null) {\r\n        // There's still work remaining. Request another callback.\r\n        ensureHostCallbackIsScheduled();\r\n      } else {\r\n        isHostCallbackScheduled = false;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction flushWork(didTimeout) {\r\n  // Exit right away if we're currently paused\r\n\r\n  if (enableSchedulerDebugging && isSchedulerPaused) {\r\n    return;\r\n  }\r\n\r\n  isExecutingCallback = true;\r\n  var previousDidTimeout = currentDidTimeout;\r\n  currentDidTimeout = didTimeout;\r\n  try {\r\n    if (didTimeout) {\r\n      // Flush all the expired callbacks without yielding.\r\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\r\n        // TODO Wrap in feature flag\r\n        // Read the current time. Flush all the callbacks that expire at or\r\n        // earlier than that time. Then read the current time again and repeat.\r\n        // This optimizes for as few performance.now calls as possible.\r\n        var currentTime = exports.unstable_now();\r\n        if (firstCallbackNode.expirationTime <= currentTime) {\r\n          do {\r\n            flushFirstCallback();\r\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n    } else {\r\n      // Keep flushing callbacks until we run out of time in the frame.\r\n      if (firstCallbackNode !== null) {\r\n        do {\r\n          if (enableSchedulerDebugging && isSchedulerPaused) {\r\n            break;\r\n          }\r\n          flushFirstCallback();\r\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\r\n      }\r\n    }\r\n  } finally {\r\n    isExecutingCallback = false;\r\n    currentDidTimeout = previousDidTimeout;\r\n    if (firstCallbackNode !== null) {\r\n      // There's still work remaining. Request another callback.\r\n      ensureHostCallbackIsScheduled();\r\n    } else {\r\n      isHostCallbackScheduled = false;\r\n    }\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n    case LowPriority:\r\n    case IdlePriority:\r\n      break;\r\n    default:\r\n      priorityLevel = NormalPriority;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousEventStartTime = currentEventStartTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentEventStartTime = exports.unstable_now();\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentEventStartTime = previousEventStartTime;\r\n\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_next(eventHandler) {\r\n  var priorityLevel = void 0;\r\n  switch (currentPriorityLevel) {\r\n    case ImmediatePriority:\r\n    case UserBlockingPriority:\r\n    case NormalPriority:\r\n      // Shift down to normal priority\r\n      priorityLevel = NormalPriority;\r\n      break;\r\n    default:\r\n      // Anything lower than normal priority should remain at the current level.\r\n      priorityLevel = currentPriorityLevel;\r\n      break;\r\n  }\r\n\r\n  var previousPriorityLevel = currentPriorityLevel;\r\n  var previousEventStartTime = currentEventStartTime;\r\n  currentPriorityLevel = priorityLevel;\r\n  currentEventStartTime = exports.unstable_now();\r\n\r\n  try {\r\n    return eventHandler();\r\n  } finally {\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    currentEventStartTime = previousEventStartTime;\r\n\r\n    // Before exiting, flush all the immediate work that was scheduled.\r\n    flushImmediateWork();\r\n  }\r\n}\r\n\r\nfunction unstable_wrapCallback(callback) {\r\n  var parentPriorityLevel = currentPriorityLevel;\r\n  return function () {\r\n    // This is a fork of runWithPriority, inlined for performance.\r\n    var previousPriorityLevel = currentPriorityLevel;\r\n    var previousEventStartTime = currentEventStartTime;\r\n    currentPriorityLevel = parentPriorityLevel;\r\n    currentEventStartTime = exports.unstable_now();\r\n\r\n    try {\r\n      return callback.apply(this, arguments);\r\n    } finally {\r\n      currentPriorityLevel = previousPriorityLevel;\r\n      currentEventStartTime = previousEventStartTime;\r\n      flushImmediateWork();\r\n    }\r\n  };\r\n}\r\n\r\nfunction unstable_scheduleCallback(callback, deprecated_options) {\r\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\r\n\r\n  var expirationTime;\r\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\r\n    // FIXME: Remove this branch once we lift expiration times out of React.\r\n    expirationTime = startTime + deprecated_options.timeout;\r\n  } else {\r\n    switch (currentPriorityLevel) {\r\n      case ImmediatePriority:\r\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\r\n        break;\r\n      case UserBlockingPriority:\r\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\r\n        break;\r\n      case IdlePriority:\r\n        expirationTime = startTime + IDLE_PRIORITY;\r\n        break;\r\n      case LowPriority:\r\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\r\n        break;\r\n      case NormalPriority:\r\n      default:\r\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\r\n    }\r\n  }\r\n\r\n  var newNode = {\r\n    callback: callback,\r\n    priorityLevel: currentPriorityLevel,\r\n    expirationTime: expirationTime,\r\n    next: null,\r\n    previous: null\r\n  };\r\n\r\n  // Insert the new callback into the list, ordered first by expiration, then\r\n  // by insertion. So the new callback is inserted any other callback with\r\n  // equal expiration.\r\n  if (firstCallbackNode === null) {\r\n    // This is the first callback in the list.\r\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\r\n    ensureHostCallbackIsScheduled();\r\n  } else {\r\n    var next = null;\r\n    var node = firstCallbackNode;\r\n    do {\r\n      if (node.expirationTime > expirationTime) {\r\n        // The new callback expires before this one.\r\n        next = node;\r\n        break;\r\n      }\r\n      node = node.next;\r\n    } while (node !== firstCallbackNode);\r\n\r\n    if (next === null) {\r\n      // No callback with a later expiration was found, which means the new\r\n      // callback has the latest expiration in the list.\r\n      next = firstCallbackNode;\r\n    } else if (next === firstCallbackNode) {\r\n      // The new callback has the earliest expiration in the entire list.\r\n      firstCallbackNode = newNode;\r\n      ensureHostCallbackIsScheduled();\r\n    }\r\n\r\n    var previous = next.previous;\r\n    previous.next = next.previous = newNode;\r\n    newNode.next = next;\r\n    newNode.previous = previous;\r\n  }\r\n\r\n  return newNode;\r\n}\r\n\r\nfunction unstable_pauseExecution() {\r\n  isSchedulerPaused = true;\r\n}\r\n\r\nfunction unstable_continueExecution() {\r\n  isSchedulerPaused = false;\r\n  if (firstCallbackNode !== null) {\r\n    ensureHostCallbackIsScheduled();\r\n  }\r\n}\r\n\r\nfunction unstable_getFirstCallbackNode() {\r\n  return firstCallbackNode;\r\n}\r\n\r\nfunction unstable_cancelCallback(callbackNode) {\r\n  var next = callbackNode.next;\r\n  if (next === null) {\r\n    // Already cancelled.\r\n    return;\r\n  }\r\n\r\n  if (next === callbackNode) {\r\n    // This is the only scheduled callback. Clear the list.\r\n    firstCallbackNode = null;\r\n  } else {\r\n    // Remove the callback from its position in the list.\r\n    if (callbackNode === firstCallbackNode) {\r\n      firstCallbackNode = next;\r\n    }\r\n    var previous = callbackNode.previous;\r\n    previous.next = next;\r\n    next.previous = previous;\r\n  }\r\n\r\n  callbackNode.next = callbackNode.previous = null;\r\n}\r\n\r\nfunction unstable_getCurrentPriorityLevel() {\r\n  return currentPriorityLevel;\r\n}\r\n\r\nfunction unstable_shouldYield() {\r\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\r\n}\r\n\r\n// The remaining code is essentially a polyfill for requestIdleCallback. It\r\n// works by scheduling a requestAnimationFrame, storing the time for the start\r\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\r\n// Within the postMessage handler do as much work as possible until time + frame\r\n// rate. By separating the idle call into a separate event tick we ensure that\r\n// layout, paint and other browser work is counted against the available time.\r\n// The frame rate is dynamically adjusted.\r\n\r\n// We capture a local reference to any global, in case it gets polyfilled after\r\n// this module is initially evaluated. We want to be using a\r\n// consistent implementation.\r\nvar localDate = Date;\r\n\r\n// This initialization code may run even on server environments if a component\r\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\r\n// have setTimeout or clearTimeout. However, we always expect them to be defined\r\n// on the client. https://github.com/facebook/react/pull/13088\r\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\r\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\r\n\r\n// We don't expect either of these to necessarily be defined, but we will error\r\n// later if they are missing on the client.\r\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\r\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\r\n\r\n// requestAnimationFrame does not run when the tab is in the background. If\r\n// we're backgrounded we prefer for that work to happen so that the page\r\n// continues to load in the background. So we also schedule a 'setTimeout' as\r\n// a fallback.\r\n// TODO: Need a better heuristic for backgrounded work.\r\nvar ANIMATION_FRAME_TIMEOUT = 100;\r\nvar rAFID;\r\nvar rAFTimeoutID;\r\nvar requestAnimationFrameWithTimeout = function (callback) {\r\n  // schedule rAF and also a setTimeout\r\n  rAFID = localRequestAnimationFrame(function (timestamp) {\r\n    // cancel the setTimeout\r\n    localClearTimeout(rAFTimeoutID);\r\n    callback(timestamp);\r\n  });\r\n  rAFTimeoutID = localSetTimeout(function () {\r\n    // cancel the requestAnimationFrame\r\n    localCancelAnimationFrame(rAFID);\r\n    callback(exports.unstable_now());\r\n  }, ANIMATION_FRAME_TIMEOUT);\r\n};\r\n\r\nif (hasNativePerformanceNow) {\r\n  var Performance = performance;\r\n  exports.unstable_now = function () {\r\n    return Performance.now();\r\n  };\r\n} else {\r\n  exports.unstable_now = function () {\r\n    return localDate.now();\r\n  };\r\n}\r\n\r\nvar requestHostCallback;\r\nvar cancelHostCallback;\r\nvar shouldYieldToHost;\r\n\r\nvar globalValue = null;\r\nif (typeof window !== 'undefined') {\r\n  globalValue = window;\r\n} else if (typeof global !== 'undefined') {\r\n  globalValue = global;\r\n}\r\n\r\nif (globalValue && globalValue._schedMock) {\r\n  // Dynamic injection, only for testing purposes.\r\n  var globalImpl = globalValue._schedMock;\r\n  requestHostCallback = globalImpl[0];\r\n  cancelHostCallback = globalImpl[1];\r\n  shouldYieldToHost = globalImpl[2];\r\n  exports.unstable_now = globalImpl[3];\r\n} else if (\r\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\r\n// implementation using setTimeout.\r\ntypeof window === 'undefined' ||\r\n// Check if MessageChannel is supported, too.\r\ntypeof MessageChannel !== 'function') {\r\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\r\n  // fallback to a naive implementation.\r\n  var _callback = null;\r\n  var _flushCallback = function (didTimeout) {\r\n    if (_callback !== null) {\r\n      try {\r\n        _callback(didTimeout);\r\n      } finally {\r\n        _callback = null;\r\n      }\r\n    }\r\n  };\r\n  requestHostCallback = function (cb, ms) {\r\n    if (_callback !== null) {\r\n      // Protect against re-entrancy.\r\n      setTimeout(requestHostCallback, 0, cb);\r\n    } else {\r\n      _callback = cb;\r\n      setTimeout(_flushCallback, 0, false);\r\n    }\r\n  };\r\n  cancelHostCallback = function () {\r\n    _callback = null;\r\n  };\r\n  shouldYieldToHost = function () {\r\n    return false;\r\n  };\r\n} else {\r\n  if (typeof console !== 'undefined') {\r\n    // TODO: Remove fb.me link\r\n    if (typeof localRequestAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n    if (typeof localCancelAnimationFrame !== 'function') {\r\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\r\n    }\r\n  }\r\n\r\n  var scheduledHostCallback = null;\r\n  var isMessageEventScheduled = false;\r\n  var timeoutTime = -1;\r\n\r\n  var isAnimationFrameScheduled = false;\r\n\r\n  var isFlushingHostCallback = false;\r\n\r\n  var frameDeadline = 0;\r\n  // We start out assuming that we run at 30fps but then the heuristic tracking\r\n  // will adjust this value to a faster fps if we get more frequent animation\r\n  // frames.\r\n  var previousFrameTime = 33;\r\n  var activeFrameTime = 33;\r\n\r\n  shouldYieldToHost = function () {\r\n    return frameDeadline <= exports.unstable_now();\r\n  };\r\n\r\n  // We use the postMessage trick to defer idle work until after the repaint.\r\n  var channel = new MessageChannel();\r\n  var port = channel.port2;\r\n  channel.port1.onmessage = function (event) {\r\n    isMessageEventScheduled = false;\r\n\r\n    var prevScheduledCallback = scheduledHostCallback;\r\n    var prevTimeoutTime = timeoutTime;\r\n    scheduledHostCallback = null;\r\n    timeoutTime = -1;\r\n\r\n    var currentTime = exports.unstable_now();\r\n\r\n    var didTimeout = false;\r\n    if (frameDeadline - currentTime <= 0) {\r\n      // There's no time left in this idle period. Check if the callback has\r\n      // a timeout and whether it's been exceeded.\r\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\r\n        // Exceeded the timeout. Invoke the callback even though there's no\r\n        // time left.\r\n        didTimeout = true;\r\n      } else {\r\n        // No timeout.\r\n        if (!isAnimationFrameScheduled) {\r\n          // Schedule another animation callback so we retry later.\r\n          isAnimationFrameScheduled = true;\r\n          requestAnimationFrameWithTimeout(animationTick);\r\n        }\r\n        // Exit without invoking the callback.\r\n        scheduledHostCallback = prevScheduledCallback;\r\n        timeoutTime = prevTimeoutTime;\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (prevScheduledCallback !== null) {\r\n      isFlushingHostCallback = true;\r\n      try {\r\n        prevScheduledCallback(didTimeout);\r\n      } finally {\r\n        isFlushingHostCallback = false;\r\n      }\r\n    }\r\n  };\r\n\r\n  var animationTick = function (rafTime) {\r\n    if (scheduledHostCallback !== null) {\r\n      // Eagerly schedule the next animation callback at the beginning of the\r\n      // frame. If the scheduler queue is not empty at the end of the frame, it\r\n      // will continue flushing inside that callback. If the queue *is* empty,\r\n      // then it will exit immediately. Posting the callback at the start of the\r\n      // frame ensures it's fired within the earliest possible frame. If we\r\n      // waited until the end of the frame to post the callback, we risk the\r\n      // browser skipping a frame and not firing the callback until the frame\r\n      // after that.\r\n      requestAnimationFrameWithTimeout(animationTick);\r\n    } else {\r\n      // No pending work. Exit.\r\n      isAnimationFrameScheduled = false;\r\n      return;\r\n    }\r\n\r\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\r\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\r\n      if (nextFrameTime < 8) {\r\n        // Defensive coding. We don't support higher frame rates than 120hz.\r\n        // If the calculated frame time gets lower than 8, it is probably a bug.\r\n        nextFrameTime = 8;\r\n      }\r\n      // If one frame goes long, then the next one can be short to catch up.\r\n      // If two frames are short in a row, then that's an indication that we\r\n      // actually have a higher frame rate than what we're currently optimizing.\r\n      // We adjust our heuristic dynamically accordingly. For example, if we're\r\n      // running on 120hz display or 90hz VR display.\r\n      // Take the max of the two in case one of them was an anomaly due to\r\n      // missed frame deadlines.\r\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\r\n    } else {\r\n      previousFrameTime = nextFrameTime;\r\n    }\r\n    frameDeadline = rafTime + activeFrameTime;\r\n    if (!isMessageEventScheduled) {\r\n      isMessageEventScheduled = true;\r\n      port.postMessage(undefined);\r\n    }\r\n  };\r\n\r\n  requestHostCallback = function (callback, absoluteTimeout) {\r\n    scheduledHostCallback = callback;\r\n    timeoutTime = absoluteTimeout;\r\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\r\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\r\n      port.postMessage(undefined);\r\n    } else if (!isAnimationFrameScheduled) {\r\n      // If rAF didn't already schedule one, we need to schedule a frame.\r\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\r\n      // might want to still have setTimeout trigger rIC as a backup to ensure\r\n      // that we keep performing work.\r\n      isAnimationFrameScheduled = true;\r\n      requestAnimationFrameWithTimeout(animationTick);\r\n    }\r\n  };\r\n\r\n  cancelHostCallback = function () {\r\n    scheduledHostCallback = null;\r\n    isMessageEventScheduled = false;\r\n    timeoutTime = -1;\r\n  };\r\n}\r\n\r\nexports.unstable_ImmediatePriority = ImmediatePriority;\r\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\r\nexports.unstable_NormalPriority = NormalPriority;\r\nexports.unstable_IdlePriority = IdlePriority;\r\nexports.unstable_LowPriority = LowPriority;\r\nexports.unstable_runWithPriority = unstable_runWithPriority;\r\nexports.unstable_next = unstable_next;\r\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\r\nexports.unstable_cancelCallback = unstable_cancelCallback;\r\nexports.unstable_wrapCallback = unstable_wrapCallback;\r\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\nexports.unstable_shouldYield = unstable_shouldYield;\r\nexports.unstable_continueExecution = unstable_continueExecution;\r\nexports.unstable_pauseExecution = unstable_pauseExecution;\r\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n  })();\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAIA,IAAIA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;EACzC,CAAC,YAAW;IACd;;IAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;MAAEC,KAAK,EAAE;IAAT,CAA7C;IAEA,IAAIC,wBAAwB,GAAG,KAA/B;IAEA;IAEA;;IACA,IAAIC,iBAAiB,GAAG,CAAxB;IACA,IAAIC,oBAAoB,GAAG,CAA3B;IACA,IAAIC,cAAc,GAAG,CAArB;IACA,IAAIC,WAAW,GAAG,CAAlB;IACA,IAAIC,YAAY,GAAG,CAAnB,CAdc,CAgBd;IACA;IACA;;IACA,IAAIC,iBAAiB,GAAG,UAAxB,CAnBc,CAqBd;;IACA,IAAIC,0BAA0B,GAAG,CAAC,CAAlC,CAtBc,CAuBd;;IACA,IAAIC,sBAAsB,GAAG,GAA7B;IACA,IAAIC,uBAAuB,GAAG,IAA9B;IACA,IAAIC,oBAAoB,GAAG,KAA3B,CA1Bc,CA2Bd;;IACA,IAAIC,aAAa,GAAGL,iBAApB,CA5Bc,CA8Bd;;IACA,IAAIM,iBAAiB,GAAG,IAAxB;IAEA,IAAIC,iBAAiB,GAAG,KAAxB,CAjCc,CAkCd;;IACA,IAAIC,iBAAiB,GAAG,KAAxB;IAEA,IAAIC,oBAAoB,GAAGZ,cAA3B;IACA,IAAIa,qBAAqB,GAAG,CAAC,CAA7B;IACA,IAAIC,qBAAqB,GAAG,CAAC,CAA7B,CAvCc,CAyCd;;IACA,IAAIC,mBAAmB,GAAG,KAA1B;IAEA,IAAIC,uBAAuB,GAAG,KAA9B;IAEA,IAAIC,uBAAuB,GAAG,OAAOC,WAAP,KAAuB,QAAvB,IAAmC,OAAOA,WAAW,CAACC,GAAnB,KAA2B,UAA5F;;IAEA,SAASC,6BAAT,GAAyC;MACvC,IAAIL,mBAAJ,EAAyB;QACvB;QACA;MACD,CAJsC,CAKvC;;;MACA,IAAIM,cAAc,GAAGZ,iBAAiB,CAACY,cAAvC;;MACA,IAAI,CAACL,uBAAL,EAA8B;QAC5BA,uBAAuB,GAAG,IAA1B;MACD,CAFD,MAEO;QACL;QACAM,kBAAkB;MACnB;;MACDC,oBAAmB,CAACC,SAAD,EAAYH,cAAZ,CAAnB;IACD;;IAED,SAASI,kBAAT,GAA8B;MAC5B,IAAIC,WAAW,GAAGjB,iBAAlB,CAD4B,CAG5B;MACA;;MACA,IAAIkB,IAAI,GAAGlB,iBAAiB,CAACkB,IAA7B;;MACA,IAAIlB,iBAAiB,KAAKkB,IAA1B,EAAgC;QAC9B;QACAlB,iBAAiB,GAAG,IAApB;QACAkB,IAAI,GAAG,IAAP;MACD,CAJD,MAIO;QACL,IAAIC,gBAAgB,GAAGnB,iBAAiB,CAACoB,QAAzC;QACApB,iBAAiB,GAAGmB,gBAAgB,CAACD,IAAjB,GAAwBA,IAA5C;QACAA,IAAI,CAACE,QAAL,GAAgBD,gBAAhB;MACD;;MAEDF,WAAW,CAACC,IAAZ,GAAmBD,WAAW,CAACG,QAAZ,GAAuB,IAA1C,CAhB4B,CAkB5B;;MACA,IAAIC,QAAQ,GAAGJ,WAAW,CAACI,QAA3B;MACA,IAAIT,cAAc,GAAGK,WAAW,CAACL,cAAjC;MACA,IAAIU,aAAa,GAAGL,WAAW,CAACK,aAAhC;MACA,IAAIC,qBAAqB,GAAGpB,oBAA5B;MACA,IAAIqB,sBAAsB,GAAGnB,qBAA7B;MACAF,oBAAoB,GAAGmB,aAAvB;MACAjB,qBAAqB,GAAGO,cAAxB;MACA,IAAIa,oBAAJ;;MACA,IAAI;QACFA,oBAAoB,GAAGJ,QAAQ,EAA/B;MACD,CAFD,SAEU;QACRlB,oBAAoB,GAAGoB,qBAAvB;QACAlB,qBAAqB,GAAGmB,sBAAxB;MACD,CAhC2B,CAkC5B;MACA;;;MACA,IAAI,OAAOC,oBAAP,KAAgC,UAApC,EAAgD;QAC9C,IAAIC,gBAAgB,GAAG;UACrBL,QAAQ,EAAEI,oBADW;UAErBH,aAAa,EAAEA,aAFM;UAGrBV,cAAc,EAAEA,cAHK;UAIrBM,IAAI,EAAE,IAJe;UAKrBE,QAAQ,EAAE;QALW,CAAvB,CAD8C,CAS9C;QACA;QACA;QACA;;QACA,IAAIpB,iBAAiB,KAAK,IAA1B,EAAgC;UAC9B;UACAA,iBAAiB,GAAG0B,gBAAgB,CAACR,IAAjB,GAAwBQ,gBAAgB,CAACN,QAAjB,GAA4BM,gBAAxE;QACD,CAHD,MAGO;UACL,IAAIC,qBAAqB,GAAG,IAA5B;UACA,IAAIC,IAAI,GAAG5B,iBAAX;;UACA,GAAG;YACD,IAAI4B,IAAI,CAAChB,cAAL,IAAuBA,cAA3B,EAA2C;cACzC;cACA;cACAe,qBAAqB,GAAGC,IAAxB;cACA;YACD;;YACDA,IAAI,GAAGA,IAAI,CAACV,IAAZ;UACD,CARD,QAQSU,IAAI,KAAK5B,iBARlB;;UAUA,IAAI2B,qBAAqB,KAAK,IAA9B,EAAoC;YAClC;YACA;YACAA,qBAAqB,GAAG3B,iBAAxB;UACD,CAJD,MAIO,IAAI2B,qBAAqB,KAAK3B,iBAA9B,EAAiD;YACtD;YACAA,iBAAiB,GAAG0B,gBAApB;YACAf,6BAA6B;UAC9B;;UAED,IAAIS,QAAQ,GAAGO,qBAAqB,CAACP,QAArC;UACAA,QAAQ,CAACF,IAAT,GAAgBS,qBAAqB,CAACP,QAAtB,GAAiCM,gBAAjD;UACAA,gBAAgB,CAACR,IAAjB,GAAwBS,qBAAxB;UACAD,gBAAgB,CAACN,QAAjB,GAA4BA,QAA5B;QACD;MACF;IACF;;IAED,SAASS,kBAAT,GAA8B;MAC5B,KACA;MACAzB,qBAAqB,KAAK,CAAC,CAA3B,IAAgCJ,iBAAiB,KAAK,IAAtD,IAA8DA,iBAAiB,CAACsB,aAAlB,KAAoCjC,iBAFlG,EAEqH;QACnHiB,mBAAmB,GAAG,IAAtB;;QACA,IAAI;UACF,GAAG;YACDU,kBAAkB;UACnB,CAFD,SAGA;UACAhB,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACsB,aAAlB,KAAoCjC,iBAJlE;QAKD,CAND,SAMU;UACRiB,mBAAmB,GAAG,KAAtB;;UACA,IAAIN,iBAAiB,KAAK,IAA1B,EAAgC;YAC9B;YACAW,6BAA6B;UAC9B,CAHD,MAGO;YACLJ,uBAAuB,GAAG,KAA1B;UACD;QACF;MACF;IACF;;IAED,SAASQ,SAAT,CAAmBe,UAAnB,EAA+B;MAC7B;MAEA,IAAI1C,wBAAwB,IAAIc,iBAAhC,EAAmD;QACjD;MACD;;MAEDI,mBAAmB,GAAG,IAAtB;MACA,IAAIyB,kBAAkB,GAAG9B,iBAAzB;MACAA,iBAAiB,GAAG6B,UAApB;;MACA,IAAI;QACF,IAAIA,UAAJ,EAAgB;UACd;UACA,OAAO9B,iBAAiB,KAAK,IAAtB,IAA8B,EAAEZ,wBAAwB,IAAIc,iBAA9B,CAArC,EAAuF;YACrF;YACA;YACA;YACA;YACA,IAAI8B,WAAW,GAAG9C,OAAO,CAAC+C,YAAR,EAAlB;;YACA,IAAIjC,iBAAiB,CAACY,cAAlB,IAAoCoB,WAAxC,EAAqD;cACnD,GAAG;gBACDhB,kBAAkB;cACnB,CAFD,QAEShB,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACY,cAAlB,IAAoCoB,WAAlE,IAAiF,EAAE5C,wBAAwB,IAAIc,iBAA9B,CAF1F;;cAGA;YACD;;YACD;UACD;QACF,CAhBD,MAgBO;UACL;UACA,IAAIF,iBAAiB,KAAK,IAA1B,EAAgC;YAC9B,GAAG;cACD,IAAIZ,wBAAwB,IAAIc,iBAAhC,EAAmD;gBACjD;cACD;;cACDc,kBAAkB;YACnB,CALD,QAKShB,iBAAiB,KAAK,IAAtB,IAA8B,CAACkC,iBAAiB,EALzD;UAMD;QACF;MACF,CA5BD,SA4BU;QACR5B,mBAAmB,GAAG,KAAtB;QACAL,iBAAiB,GAAG8B,kBAApB;;QACA,IAAI/B,iBAAiB,KAAK,IAA1B,EAAgC;UAC9B;UACAW,6BAA6B;QAC9B,CAHD,MAGO;UACLJ,uBAAuB,GAAG,KAA1B;QACD,CARO,CASR;;;QACAsB,kBAAkB;MACnB;IACF;;IAED,SAASM,wBAAT,CAAkCb,aAAlC,EAAiDc,YAAjD,EAA+D;MAC7D,QAAQd,aAAR;QACE,KAAKjC,iBAAL;QACA,KAAKC,oBAAL;QACA,KAAKC,cAAL;QACA,KAAKC,WAAL;QACA,KAAKC,YAAL;UACE;;QACF;UACE6B,aAAa,GAAG/B,cAAhB;MARJ;;MAWA,IAAIgC,qBAAqB,GAAGpB,oBAA5B;MACA,IAAIkC,sBAAsB,GAAGjC,qBAA7B;MACAD,oBAAoB,GAAGmB,aAAvB;MACAlB,qBAAqB,GAAGlB,OAAO,CAAC+C,YAAR,EAAxB;;MAEA,IAAI;QACF,OAAOG,YAAY,EAAnB;MACD,CAFD,SAEU;QACRjC,oBAAoB,GAAGoB,qBAAvB;QACAnB,qBAAqB,GAAGiC,sBAAxB,CAFQ,CAIR;;QACAR,kBAAkB;MACnB;IACF;;IAED,SAASS,aAAT,CAAuBF,YAAvB,EAAqC;MACnC,IAAId,aAAa,GAAG,KAAK,CAAzB;;MACA,QAAQnB,oBAAR;QACE,KAAKd,iBAAL;QACA,KAAKC,oBAAL;QACA,KAAKC,cAAL;UACE;UACA+B,aAAa,GAAG/B,cAAhB;UACA;;QACF;UACE;UACA+B,aAAa,GAAGnB,oBAAhB;UACA;MAVJ;;MAaA,IAAIoB,qBAAqB,GAAGpB,oBAA5B;MACA,IAAIkC,sBAAsB,GAAGjC,qBAA7B;MACAD,oBAAoB,GAAGmB,aAAvB;MACAlB,qBAAqB,GAAGlB,OAAO,CAAC+C,YAAR,EAAxB;;MAEA,IAAI;QACF,OAAOG,YAAY,EAAnB;MACD,CAFD,SAEU;QACRjC,oBAAoB,GAAGoB,qBAAvB;QACAnB,qBAAqB,GAAGiC,sBAAxB,CAFQ,CAIR;;QACAR,kBAAkB;MACnB;IACF;;IAED,SAASU,qBAAT,CAA+BlB,QAA/B,EAAyC;MACvC,IAAImB,mBAAmB,GAAGrC,oBAA1B;MACA,OAAO,YAAY;QACjB;QACA,IAAIoB,qBAAqB,GAAGpB,oBAA5B;QACA,IAAIkC,sBAAsB,GAAGjC,qBAA7B;QACAD,oBAAoB,GAAGqC,mBAAvB;QACApC,qBAAqB,GAAGlB,OAAO,CAAC+C,YAAR,EAAxB;;QAEA,IAAI;UACF,OAAOZ,QAAQ,CAACoB,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAAP;QACD,CAFD,SAEU;UACRvC,oBAAoB,GAAGoB,qBAAvB;UACAnB,qBAAqB,GAAGiC,sBAAxB;UACAR,kBAAkB;QACnB;MACF,CAdD;IAeD;;IAED,SAASc,yBAAT,CAAmCtB,QAAnC,EAA6CuB,kBAA7C,EAAiE;MAC/D,IAAIC,SAAS,GAAGzC,qBAAqB,KAAK,CAAC,CAA3B,GAA+BA,qBAA/B,GAAuDlB,OAAO,CAAC+C,YAAR,EAAvE;MAEA,IAAIrB,cAAJ;;MACA,IAAI,OAAOgC,kBAAP,KAA8B,QAA9B,IAA0CA,kBAAkB,KAAK,IAAjE,IAAyE,OAAOA,kBAAkB,CAACE,OAA1B,KAAsC,QAAnH,EAA6H;QAC3H;QACAlC,cAAc,GAAGiC,SAAS,GAAGD,kBAAkB,CAACE,OAAhD;MACD,CAHD,MAGO;QACL,QAAQ3C,oBAAR;UACE,KAAKd,iBAAL;YACEuB,cAAc,GAAGiC,SAAS,GAAGlD,0BAA7B;YACA;;UACF,KAAKL,oBAAL;YACEsB,cAAc,GAAGiC,SAAS,GAAGjD,sBAA7B;YACA;;UACF,KAAKH,YAAL;YACEmB,cAAc,GAAGiC,SAAS,GAAG9C,aAA7B;YACA;;UACF,KAAKP,WAAL;YACEoB,cAAc,GAAGiC,SAAS,GAAG/C,oBAA7B;YACA;;UACF,KAAKP,cAAL;UACA;YACEqB,cAAc,GAAGiC,SAAS,GAAGhD,uBAA7B;QAfJ;MAiBD;;MAED,IAAIkD,OAAO,GAAG;QACZ1B,QAAQ,EAAEA,QADE;QAEZC,aAAa,EAAEnB,oBAFH;QAGZS,cAAc,EAAEA,cAHJ;QAIZM,IAAI,EAAE,IAJM;QAKZE,QAAQ,EAAE;MALE,CAAd,CA3B+D,CAmC/D;MACA;MACA;;MACA,IAAIpB,iBAAiB,KAAK,IAA1B,EAAgC;QAC9B;QACAA,iBAAiB,GAAG+C,OAAO,CAAC7B,IAAR,GAAe6B,OAAO,CAAC3B,QAAR,GAAmB2B,OAAtD;QACApC,6BAA6B;MAC9B,CAJD,MAIO;QACL,IAAIO,IAAI,GAAG,IAAX;QACA,IAAIU,IAAI,GAAG5B,iBAAX;;QACA,GAAG;UACD,IAAI4B,IAAI,CAAChB,cAAL,GAAsBA,cAA1B,EAA0C;YACxC;YACAM,IAAI,GAAGU,IAAP;YACA;UACD;;UACDA,IAAI,GAAGA,IAAI,CAACV,IAAZ;QACD,CAPD,QAOSU,IAAI,KAAK5B,iBAPlB;;QASA,IAAIkB,IAAI,KAAK,IAAb,EAAmB;UACjB;UACA;UACAA,IAAI,GAAGlB,iBAAP;QACD,CAJD,MAIO,IAAIkB,IAAI,KAAKlB,iBAAb,EAAgC;UACrC;UACAA,iBAAiB,GAAG+C,OAApB;UACApC,6BAA6B;QAC9B;;QAED,IAAIS,QAAQ,GAAGF,IAAI,CAACE,QAApB;QACAA,QAAQ,CAACF,IAAT,GAAgBA,IAAI,CAACE,QAAL,GAAgB2B,OAAhC;QACAA,OAAO,CAAC7B,IAAR,GAAeA,IAAf;QACA6B,OAAO,CAAC3B,QAAR,GAAmBA,QAAnB;MACD;;MAED,OAAO2B,OAAP;IACD;;IAED,SAASC,uBAAT,GAAmC;MACjC9C,iBAAiB,GAAG,IAApB;IACD;;IAED,SAAS+C,0BAAT,GAAsC;MACpC/C,iBAAiB,GAAG,KAApB;;MACA,IAAIF,iBAAiB,KAAK,IAA1B,EAAgC;QAC9BW,6BAA6B;MAC9B;IACF;;IAED,SAASuC,6BAAT,GAAyC;MACvC,OAAOlD,iBAAP;IACD;;IAED,SAASmD,uBAAT,CAAiCC,YAAjC,EAA+C;MAC7C,IAAIlC,IAAI,GAAGkC,YAAY,CAAClC,IAAxB;;MACA,IAAIA,IAAI,KAAK,IAAb,EAAmB;QACjB;QACA;MACD;;MAED,IAAIA,IAAI,KAAKkC,YAAb,EAA2B;QACzB;QACApD,iBAAiB,GAAG,IAApB;MACD,CAHD,MAGO;QACL;QACA,IAAIoD,YAAY,KAAKpD,iBAArB,EAAwC;UACtCA,iBAAiB,GAAGkB,IAApB;QACD;;QACD,IAAIE,QAAQ,GAAGgC,YAAY,CAAChC,QAA5B;QACAA,QAAQ,CAACF,IAAT,GAAgBA,IAAhB;QACAA,IAAI,CAACE,QAAL,GAAgBA,QAAhB;MACD;;MAEDgC,YAAY,CAAClC,IAAb,GAAoBkC,YAAY,CAAChC,QAAb,GAAwB,IAA5C;IACD;;IAED,SAASiC,gCAAT,GAA4C;MAC1C,OAAOlD,oBAAP;IACD;;IAED,SAASmD,oBAAT,GAAgC;MAC9B,OAAO,CAACrD,iBAAD,KAAuBD,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACY,cAAlB,GAAmCP,qBAAjE,IAA0F6B,iBAAiB,EAAlI,CAAP;IACD,CAjaa,CAmad;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;;;IACA,IAAIqB,SAAS,GAAGC,IAAhB,CA9ac,CAgbd;IACA;IACA;IACA;;IACA,IAAIC,eAAe,GAAG,OAAOC,UAAP,KAAsB,UAAtB,GAAmCA,UAAnC,GAAgDC,SAAtE;IACA,IAAIC,iBAAiB,GAAG,OAAOC,YAAP,KAAwB,UAAxB,GAAqCA,YAArC,GAAoDF,SAA5E,CArbc,CAubd;IACA;;IACA,IAAIG,0BAA0B,GAAG,OAAOC,qBAAP,KAAiC,UAAjC,GAA8CA,qBAA9C,GAAsEJ,SAAvG;IACA,IAAIK,yBAAyB,GAAG,OAAOC,oBAAP,KAAgC,UAAhC,GAA6CA,oBAA7C,GAAoEN,SAApG,CA1bc,CA4bd;IACA;IACA;IACA;IACA;;IACA,IAAIO,uBAAuB,GAAG,GAA9B;IACA,IAAIC,KAAJ;IACA,IAAIC,YAAJ;;IACA,IAAIC,gCAAgC,GAAG,SAAnCA,gCAAmC,CAAUhD,QAAV,EAAoB;MACzD;MACA8C,KAAK,GAAGL,0BAA0B,CAAC,UAAUQ,SAAV,EAAqB;QACtD;QACAV,iBAAiB,CAACQ,YAAD,CAAjB;QACA/C,QAAQ,CAACiD,SAAD,CAAR;MACD,CAJiC,CAAlC;MAKAF,YAAY,GAAGX,eAAe,CAAC,YAAY;QACzC;QACAO,yBAAyB,CAACG,KAAD,CAAzB;QACA9C,QAAQ,CAACnC,OAAO,CAAC+C,YAAR,EAAD,CAAR;MACD,CAJ6B,EAI3BiC,uBAJ2B,CAA9B;IAKD,CAZD;;IAcA,IAAI1D,uBAAJ,EAA6B;MAC3B,IAAI+D,WAAW,GAAG9D,WAAlB;;MACAvB,OAAO,CAAC+C,YAAR,GAAuB,YAAY;QACjC,OAAOsC,WAAW,CAAC7D,GAAZ,EAAP;MACD,CAFD;IAGD,CALD,MAKO;MACLxB,OAAO,CAAC+C,YAAR,GAAuB,YAAY;QACjC,OAAOsB,SAAS,CAAC7C,GAAV,EAAP;MACD,CAFD;IAGD;;IAED,IAAII,oBAAJ;;IACA,IAAID,kBAAJ;IACA,IAAIqB,iBAAJ;IAEA,IAAIsC,WAAW,GAAG,IAAlB;;IACA,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;MACjCD,WAAW,GAAGC,MAAd;IACD,CAFD,MAEO,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;MACxCF,WAAW,GAAGE,MAAd;IACD;;IAED,IAAIF,WAAW,IAAIA,WAAW,CAACG,UAA/B,EAA2C;MACzC;MACA,IAAIC,UAAU,GAAGJ,WAAW,CAACG,UAA7B;MACA7D,oBAAmB,GAAG8D,UAAU,CAAC,CAAD,CAAhC;MACA/D,kBAAkB,GAAG+D,UAAU,CAAC,CAAD,CAA/B;MACA1C,iBAAiB,GAAG0C,UAAU,CAAC,CAAD,CAA9B;MACA1F,OAAO,CAAC+C,YAAR,GAAuB2C,UAAU,CAAC,CAAD,CAAjC;IACD,CAPD,MAOO,KACP;IACA;IACA,OAAOH,MAAP,KAAkB,WAAlB,IACA;IACA,OAAOI,cAAP,KAA0B,UALnB,EAK+B;MACpC;MACA;MACA,IAAIC,SAAS,GAAG,IAAhB;;MACA,IAAIC,cAAc,GAAG,SAAjBA,cAAiB,CAAUjD,UAAV,EAAsB;QACzC,IAAIgD,SAAS,KAAK,IAAlB,EAAwB;UACtB,IAAI;YACFA,SAAS,CAAChD,UAAD,CAAT;UACD,CAFD,SAEU;YACRgD,SAAS,GAAG,IAAZ;UACD;QACF;MACF,CARD;;MASAhE,oBAAmB,GAAG,6BAAUkE,EAAV,EAAcC,EAAd,EAAkB;QACtC,IAAIH,SAAS,KAAK,IAAlB,EAAwB;UACtB;UACApB,UAAU,CAAC5C,oBAAD,EAAsB,CAAtB,EAAyBkE,EAAzB,CAAV;QACD,CAHD,MAGO;UACLF,SAAS,GAAGE,EAAZ;UACAtB,UAAU,CAACqB,cAAD,EAAiB,CAAjB,EAAoB,KAApB,CAAV;QACD;MACF,CARD;;MASAlE,kBAAkB,GAAG,8BAAY;QAC/BiE,SAAS,GAAG,IAAZ;MACD,CAFD;;MAGA5C,iBAAiB,GAAG,6BAAY;QAC9B,OAAO,KAAP;MACD,CAFD;IAGD,CAjCM,MAiCA;MACL,IAAI,OAAOgD,OAAP,KAAmB,WAAvB,EAAoC;QAClC;QACA,IAAI,OAAOpB,0BAAP,KAAsC,UAA1C,EAAsD;UACpDoB,OAAO,CAACC,KAAR,CAAc,yDAAyD,4BAAzD,GAAwF,2DAAtG;QACD;;QACD,IAAI,OAAOnB,yBAAP,KAAqC,UAAzC,EAAqD;UACnDkB,OAAO,CAACC,KAAR,CAAc,wDAAwD,4BAAxD,GAAuF,2DAArG;QACD;MACF;;MAED,IAAIC,qBAAqB,GAAG,IAA5B;MACA,IAAIC,uBAAuB,GAAG,KAA9B;MACA,IAAIC,WAAW,GAAG,CAAC,CAAnB;MAEA,IAAIC,yBAAyB,GAAG,KAAhC;MAEA,IAAIC,sBAAsB,GAAG,KAA7B;MAEA,IAAIC,aAAa,GAAG,CAApB,CAnBK,CAoBL;MACA;MACA;;MACA,IAAIC,iBAAiB,GAAG,EAAxB;MACA,IAAIC,eAAe,GAAG,EAAtB;;MAEAzD,iBAAiB,GAAG,6BAAY;QAC9B,OAAOuD,aAAa,IAAIvG,OAAO,CAAC+C,YAAR,EAAxB;MACD,CAFD,CA1BK,CA8BL;;;MACA,IAAI2D,OAAO,GAAG,IAAIf,cAAJ,EAAd;MACA,IAAIgB,IAAI,GAAGD,OAAO,CAACE,KAAnB;;MACAF,OAAO,CAACG,KAAR,CAAcC,SAAd,GAA0B,UAAUC,KAAV,EAAiB;QACzCZ,uBAAuB,GAAG,KAA1B;QAEA,IAAIa,qBAAqB,GAAGd,qBAA5B;QACA,IAAIe,eAAe,GAAGb,WAAtB;QACAF,qBAAqB,GAAG,IAAxB;QACAE,WAAW,GAAG,CAAC,CAAf;QAEA,IAAItD,WAAW,GAAG9C,OAAO,CAAC+C,YAAR,EAAlB;QAEA,IAAIH,UAAU,GAAG,KAAjB;;QACA,IAAI2D,aAAa,GAAGzD,WAAhB,IAA+B,CAAnC,EAAsC;UACpC;UACA;UACA,IAAImE,eAAe,KAAK,CAAC,CAArB,IAA0BA,eAAe,IAAInE,WAAjD,EAA8D;YAC5D;YACA;YACAF,UAAU,GAAG,IAAb;UACD,CAJD,MAIO;YACL;YACA,IAAI,CAACyD,yBAAL,EAAgC;cAC9B;cACAA,yBAAyB,GAAG,IAA5B;cACAlB,gCAAgC,CAAC+B,aAAD,CAAhC;YACD,CANI,CAOL;;;YACAhB,qBAAqB,GAAGc,qBAAxB;YACAZ,WAAW,GAAGa,eAAd;YACA;UACD;QACF;;QAED,IAAID,qBAAqB,KAAK,IAA9B,EAAoC;UAClCV,sBAAsB,GAAG,IAAzB;;UACA,IAAI;YACFU,qBAAqB,CAACpE,UAAD,CAArB;UACD,CAFD,SAEU;YACR0D,sBAAsB,GAAG,KAAzB;UACD;QACF;MACF,CAxCD;;MA0CA,IAAIY,aAAa,GAAG,SAAhBA,aAAgB,CAAUC,OAAV,EAAmB;QACrC,IAAIjB,qBAAqB,KAAK,IAA9B,EAAoC;UAClC;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACAf,gCAAgC,CAAC+B,aAAD,CAAhC;QACD,CAVD,MAUO;UACL;UACAb,yBAAyB,GAAG,KAA5B;UACA;QACD;;QAED,IAAIe,aAAa,GAAGD,OAAO,GAAGZ,aAAV,GAA0BE,eAA9C;;QACA,IAAIW,aAAa,GAAGX,eAAhB,IAAmCD,iBAAiB,GAAGC,eAA3D,EAA4E;UAC1E,IAAIW,aAAa,GAAG,CAApB,EAAuB;YACrB;YACA;YACAA,aAAa,GAAG,CAAhB;UACD,CALyE,CAM1E;UACA;UACA;UACA;UACA;UACA;UACA;;;UACAX,eAAe,GAAGW,aAAa,GAAGZ,iBAAhB,GAAoCA,iBAApC,GAAwDY,aAA1E;QACD,CAdD,MAcO;UACLZ,iBAAiB,GAAGY,aAApB;QACD;;QACDb,aAAa,GAAGY,OAAO,GAAGV,eAA1B;;QACA,IAAI,CAACN,uBAAL,EAA8B;UAC5BA,uBAAuB,GAAG,IAA1B;UACAQ,IAAI,CAACU,WAAL,CAAiB5C,SAAjB;QACD;MACF,CAxCD;;MA0CA7C,oBAAmB,GAAG,8BAAUO,QAAV,EAAoBmF,eAApB,EAAqC;QACzDpB,qBAAqB,GAAG/D,QAAxB;QACAiE,WAAW,GAAGkB,eAAd;;QACA,IAAIhB,sBAAsB,IAAIgB,eAAe,GAAG,CAAhD,EAAmD;UACjD;UACAX,IAAI,CAACU,WAAL,CAAiB5C,SAAjB;QACD,CAHD,MAGO,IAAI,CAAC4B,yBAAL,EAAgC;UACrC;UACA;UACA;UACA;UACAA,yBAAyB,GAAG,IAA5B;UACAlB,gCAAgC,CAAC+B,aAAD,CAAhC;QACD;MACF,CAdD;;MAgBAvF,kBAAkB,GAAG,8BAAY;QAC/BuE,qBAAqB,GAAG,IAAxB;QACAC,uBAAuB,GAAG,KAA1B;QACAC,WAAW,GAAG,CAAC,CAAf;MACD,CAJD;IAKD;;IAEDpG,OAAO,CAACuH,0BAAR,GAAqCpH,iBAArC;IACAH,OAAO,CAACwH,6BAAR,GAAwCpH,oBAAxC;IACAJ,OAAO,CAACyH,uBAAR,GAAkCpH,cAAlC;IACAL,OAAO,CAAC0H,qBAAR,GAAgCnH,YAAhC;IACAP,OAAO,CAAC2H,oBAAR,GAA+BrH,WAA/B;IACAN,OAAO,CAACiD,wBAAR,GAAmCA,wBAAnC;IACAjD,OAAO,CAACoD,aAAR,GAAwBA,aAAxB;IACApD,OAAO,CAACyD,yBAAR,GAAoCA,yBAApC;IACAzD,OAAO,CAACiE,uBAAR,GAAkCA,uBAAlC;IACAjE,OAAO,CAACqD,qBAAR,GAAgCA,qBAAhC;IACArD,OAAO,CAACmE,gCAAR,GAA2CA,gCAA3C;IACAnE,OAAO,CAACoE,oBAAR,GAA+BA,oBAA/B;IACApE,OAAO,CAAC+D,0BAAR,GAAqCA,0BAArC;IACA/D,OAAO,CAAC8D,uBAAR,GAAkCA,uBAAlC;IACA9D,OAAO,CAACgE,6BAAR,GAAwCA,6BAAxC;EACG,CA3qBD;AA4qBD"},"metadata":{},"sourceType":"script"}