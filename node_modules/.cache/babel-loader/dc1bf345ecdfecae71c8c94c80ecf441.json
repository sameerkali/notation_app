{"ast":null,"code":"import React from 'react';\nimport setRef from './setRef';\nexport default function useForkRef(refA, refB) {\n  /**\r\n   * This will create a new function if the ref props change and are defined.\r\n   * This means react will call the old forkRef with `null` and the new forkRef\r\n   * with the ref. Cleanup naturally emerges from this behavior\r\n   */\n  return React.useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}","map":{"version":3,"names":["React","setRef","useForkRef","refA","refB","useMemo","refValue"],"sources":["C:/Users/Administrator/Documents/GitHub/notation_app/node_modules/@material-ui/core/esm/utils/useForkRef.js"],"sourcesContent":["import React from 'react';\r\nimport setRef from './setRef';\r\nexport default function useForkRef(refA, refB) {\r\n  /**\r\n   * This will create a new function if the ref props change and are defined.\r\n   * This means react will call the old forkRef with `null` and the new forkRef\r\n   * with the ref. Cleanup naturally emerges from this behavior\r\n   */\r\n  return React.useMemo(function () {\r\n    if (refA == null && refB == null) {\r\n      return null;\r\n    }\r\n\r\n    return function (refValue) {\r\n      setRef(refA, refValue);\r\n      setRef(refB, refValue);\r\n    };\r\n  }, [refA, refB]);\r\n}"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,eAAe,SAASC,UAAT,CAAoBC,IAApB,EAA0BC,IAA1B,EAAgC;EAC7C;AACF;AACA;AACA;AACA;EACE,OAAOJ,KAAK,CAACK,OAAN,CAAc,YAAY;IAC/B,IAAIF,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;MAChC,OAAO,IAAP;IACD;;IAED,OAAO,UAAUE,QAAV,EAAoB;MACzBL,MAAM,CAACE,IAAD,EAAOG,QAAP,CAAN;MACAL,MAAM,CAACG,IAAD,EAAOE,QAAP,CAAN;IACD,CAHD;EAID,CATM,EASJ,CAACH,IAAD,EAAOC,IAAP,CATI,CAAP;AAUD"},"metadata":{},"sourceType":"module"}